---
title: "Flask App for Facial Recognition"
output: html_document
---

## Introduction
This repository is for a project focused on using facial recognition in a python/flask app.
To explain how the application works, first we quickly dive into the inner workings of a general web framework on Python.

1. Web Frameworks
2. Flask
3. Serving Flask applications
   1. WSGI server
   2. Web server
   3. Templating engine

#### Web Frameworks
Broadly speaking, a web framework consists of a set of libraries and a main handler within which you can build custom code to implement a web application (i.e. an interactive web site). Most web frameworks include patterns and utilities to accomplish at least the following:

* **URL Routing**  
Matches an incoming HTTP request to a particular piece of Python code to be invoked.

* **Request and Response Objects**   
Encapsulate the information received from or sent to a user’s browser.

* **Template Engine**  
Allows for separating Python code implementing an application’s logic from the HTML (or other) output that it produces.

* **Development Web Server**  
Runs an HTTP server on development machines to enable rapid development; often automatically reloads server-side code when files are updated

#### Flask
Flask is a “microframework” for Python, and is an excellent choice for building smaller applications, APIs, and web services.
Building an app with Flask is a lot like writing standard Python modules, except some functions have routes attached to them.

#### Serving Flask applications to the public  
The majority of Python applications today are hosted with a WSGI server such as Gunicorn, either directly or behind a lightweight web server such as nginx. The WSGI servers serve the applications while the web server handles tasks better suited for it such as static file serving, request routing, DDoS protection, and basic authentication.

#### 1.  WSGI server
The Web Server Gateway Interface (or “WSGI” for short) is a standard interface between web servers and Python web application frameworks. Stand-alone WSGI servers typically use less resources than traditional web servers and provide top performance.

* Gunicorn (Green Unicorn) is a pure-python WSGI server used to serve Python applications. Unlike other Python web servers, it has a thoughtful user-interface, and is extremely easy to use and configure. Gunicorn has sane and reasonable defaults for configurations. However, some other servers, like uWSGI, are tremendously more customizable, and therefore, are much more difficult to effectively use. Gunicorn is the recommended choice for new Python web applications today.

* uWSGI is a full stack for building hosting services. In addition to process management, process monitoring, and other functionality, uWSGI acts as an application server for various programming languages and protocols - including Python and WSGI. uWSGI can either be run as a stand-alone web router, or be run behind a full web server (such as Nginx or Apache). In the latter case, a web server can configure uWSGI and an application’s operation over the uwsgi protocol. uWSGI’s web server support allows for dynamically configuring Python, passing environment variables and further tuning.

#### 2. Web Server - Nginx
Nginx (pronounced “engine-x”) is a web server and reverse-proxy for HTTP, SMTP and other protocols. It is known for its high performance, relative simplicity, and compatibility with many application servers (like WSGI servers). It also includes handy features like load-balancing, basic authentication, streaming, and others. Designed to serve high-load websites, Nginx is gradually becoming quite popular.

#### 3. Templating - Jinja2
Most WSGI applications are responding to HTTP requests to serve content in HTML or other markup languages. Instead of generating directly textual content from Python, the concept of separation of concerns advises us to use templates. Jinja2 is text-based template language and can thus be used to generate any type markup, not just HTML. It allows customization of filters, tags, tests and globals.

A template engine manages a suite of template files, with a system of hierarchy and inclusion to avoid unnecessary repetition, and is in charge of rendering (generating) the actual content, filling the static content of the templates with the dynamic content generated by the application.

As template files are sometimes written by designers or front-end developers, it can be difficult to handle increasing complexity.
Some general good practices apply to the part of the application passing dynamic content to the template engine, and to the templates themselves.
*  Template files should be passed only the dynamic content that is needed for rendering the template. Avoid the temptation to pass additional content “just in case”: it is easier to add some missing variable when needed than to remove a likely unused variable later.
*  Many template engines allow for complex statements or assignments in the template itself, and many allow some Python code to be evaluated in the templates. This convenience can lead to uncontrolled increase in complexity, and often make it harder to find bugs.

